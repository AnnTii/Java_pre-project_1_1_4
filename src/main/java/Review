Что такое Maven? Для чего нужен? Как добавлять в проект библиотеки без него?
Maven — инструмент (фреймворк) для сборки и управления проектом. Это мультиплатформенный проект с открытым исходным кодом (написанный на Java), поддерживаемый Apache Software.
Он помогает на всех стадиях работы с проектом: от создания структуры проекта и подключения необходимых библиотек до развертывания продукта на сервере. На данный момент ни один серьезный проект не обходится без систем сборки и управления зависимостями, потому что вручную подключать и управлять зависимостями, а тем более транзитивными (зависимостями - зависимостей) зависимостями ОЧЕНЬ трудозатратно.
Основная фишка Maven, по сравнению, например с Ant-ом это Декларативное описание проекта (т.е. описание как должно быть, а не КАК ЭТО ДЕЛАТЬ).
Из чего состоит Maven?
- POM. Project object model. Файл - модель проекта — в нем описано из чего проект состоит и как устроен его жизненный цикл.
- Репозитории артефактов - зависимостей (библиотек).
- Утилит mvn и плагины к нему (это собственно сам инструмент сборки и управления проектом).
Как добавлять в проект библиотеки без Maven?
В IntelliJ IDEA для добавления в проект: File -> Project Structure -> Project Settings -> Libraries -> +
В модуль проекта: File -> Project Structure -> Project Settings -> Modules -> Dependencies
Как добавить dependency в Maven? Для чего? Откуда они скачиваются?
Не один серьезный проект не обходится без подключения сторонних библиотек и фреймворков. Их так же называют “Зависимости” или dependency, а в терминологии maven - артефакты.
Чтобы подключить зависимость в maven, необходимо прописать ее идентификаторы в файле конфигурации pom.xml в разделе <dependencies>.
В нем создать тег dependency в котором указать:
GAV (groupId, artifactId, version), и необязательный classifier
(когда в рамках одной версии есть библиотеки под разные JDK или ОС).
Области действия scope:
- compile (или если scope не указан): все стадии проекта
- provided: как compile, но без добавления в пакет
- system: как и provided, но maven не ищет артефакт в репе, а только по пути указанному в systemPath
- test: только на этапе тестирования
- runtime: только на стадии выполнения
- import: в зависимости типа pom, когда зависимости берутся из другого pom файла
У maven есть центральный (глобальный) репозиторий, который добавлен в конфигурацию по умолчанию. Это ресурс: mvnrepository.com
Помимо него, может быть корпоративный репозиторий команды разработчиков.
И все скачанные артефакты добавляются в локальный репозиторий на компе:
%userprofile%/.m2/repository
Адреса репозиториев maven указываются:
- в файле %userprofile%/.m2/settings.xml
- в разделе <repositories> файла pom (имеет более высокий приоритет)
Основные фазы проекта под управлением Maven?
Процесс построения приложения называют жизненным циклом Maven-проекта, он состоит из фаз (phase):
clean — удаляются все скомпилированные файлы из каталога target
(место, в котором сохраняются готовые артефакты).
validate — идет проверка, вся ли информация доступна для сборки проекта.
compile — компилирует исходники проекта.
из исходного кода (файлы .java) исполняемый байт код ( файл .class).
test — выполняются тесты скомпилированных файлов, будет использована библиотека JUnit.
package — упаковка скомпилированных файлы – по умолчанию в jar. (в jar, war, ear архив).
verify — выполняются проверки для подтверждения готовности упакованного файла.
install — копирование готового пакета (jar) в локальный репозиторий.
Теперь он может использоваться другими проектами как внешняя библиотека.
site — создается документация проекта.
deploy — собранный архив копируется в удаленный репозиторий.
Все фазы выполняются последовательно: нельзя запустить, скажем, четвертую фазы, пока не завершены фазы 1-3.
Есть две фазы, выполняющиеся отдельно, только прямой командой.
Это очистка — clean, удаляющая предыдущие сборки и создание документации для сайта — site.
Что такое JDBC? Какие классы / интерфейсы относятся к JDBC?
JDBC (Java DataBase Connectivity) - стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде драйверов, предоставляемых производителями СУБД, а также классов и интерфейсов в пакетах java.SQL.* и javax.SQL.*, т.е. являются частью JDK.
Если говорить в целом, то JDBC – это библиотека, которая обеспечивает целый набор интерфейсов для доступа к различным БД. Для доступа к каждой конкретной БД необходим специальный JDBC - драйвер, который является адаптером Java – приложения к БД.
Основные классы JDBC:
Driver - элемент отвечает за связь с БД. Работать с ним нам приходится крайне редко. Вместо этого мы чаще используем объекты DriverManager, которые управляют объектами этого типа.
DriverManager, DataSource - элемент управляет списком драйверов БД. Каждой запрос на соединение требует соответствующего драйвера. Первое совпадение дает нам соединение.
Connection - интерфейс обеспечивает нас методами для работы с БД. Все взаимодействия с БД происходят исключительно через Connection.
Statement, PreparedStatement - для подтверждения SQL-запросов мы используем объекты, созданные с использованием этого интерфейса.
ResultSet - экземпляры этого элемента содержат данные, которые были получены в результате выполнения SQL – запроса. Он работает как итератор и “пробегает” по полученным данным.
SQLException - Этот класс обрабатывает все ошибки, которые могут возникнуть при работе с БД.
Для чего нужен DriverManager?
- DriverManager автоматически загружает драйверы, которые он нашел в CLASSPATH
(до Java 6 (JDBC 4.0) нужно было это делать самостоятельно)
- с помощью метода: DriverManager.getConnection(url, user, passwd), получает Connection (подключение)
Что такое Statement, PreparedStatement, CallableStatement?
Это интерфейсы, который используется для формирования запросов к БД.
Создание: connection.createStatement()    connection.prepareStatement    connection.prepareCall()
Statement - используется для выполнения простых SQL запросов без, динамически параметров.
PrepareStatement - используется когда есть необходимость динамической вставки входных параметров в запрос. Для этого в запросе, на месте параметров, вставляют знаки вопроса “?”, а затем, с помощью специальных методов-сеттеров (setInt(), setString()), подставляются вместо вопросов конкретные значения. PreparedStatement “прекомпилирован” и использует кеширование, поэтому выполняется немного быстрее.
Statement уязвим к SQL инъекциям, а PreparedStatement нет.
CallableStatement - для выполнения хранимых в БД процедур с входными и выходными параметрами.
Для работы с БД интерфейс Statement имеет три метода, которые реализуются каждой конкретной реализацией JDBC драйвера:
boolean execute (String SQL)
Этот метод возвращает логическое значение true, если объект ResultSet может быть получен. В противном случае он возвращает false. Он используется для выполнения DDL SQL – запросов или в случаях, когда мы используем динамический SQL.
int executeUpdate (String SQL)
Этот метода возвращает количесство столбцов в таблице, на которое повлиял наш SQL – запрос. Мы используем этот метод для выполнения SQL – запросов, когда хотим получить количество задействованных столбцов, например количество данных по определенному запросу.
ResultSet executeQuery (String SQL)
Этот метод возвращает нам экземпляр ResultSet. Мы используем этот метод в случаях, когда мы рассчитываем получить множество объектов в результате выполнения нашего SQL – запроса. Например, при получении списка элементов, которые удовлетворяют определенным условиям.

Хранимые процедуры – это именованный набор операторов SQL хранящийся в базе данных.
Хранимая процедура похожа на функцию или метод в классе, за исключением того, что она находится в базе данных. CREATE PROCEDURE name_procedure (arg1 datatype, arg2 datatype,...).
Как вызвать хранимую процедуру?
без параметров → Statement
с входными параметрами → PreparedStatement
с входными и выходными параметрами → CallableStatement
Что такое sql-injection?
Это самый распространенный метод взлома web ресурсов и программ, работающих с базами данных. Он основан на внедрения дополнительного SQL-кода там, где это не ожидается.
Например в форме для ввода данных пользователя дописывают: DROP TABLE Users. Затем из этих данных формируется запрос Statement, а точнее уже 2 запроса 1 из которых удаляет таблицу.
Как защититься от sql injection?
Формировать запрос только с помощью параметров. т.е. использовать PrepareStatement
Как получить из ResultSet вторую ячейку второй строки, если в таблице, на основе которой был построен ResultSet всего три столбца и три строки?
//resultSet.next() – resulSet.get(“2”) // resultSet.absolute(int)
ResultSet содержит так называемый курсор, который позиционируется на текущей строке данных. При вызове метода next, курсор перемещается на следующую строку.
При открытии набора данных ResultSet курсор расположен перед первой строкой, и первый вызов next передвигает его на первую строку.
ResultSet хранит курсор до самого закрытия или пока не закроется родительский объект Statement.
Методы ResultSet.getXXX предоставляют доступ к значениям в колонках в текущей строке. В пределах одной строки значения могут быть считаны в любом порядке. Для обеспечения большей совместимости рекомендуется считывать их подряд слева направо и делать это только один раз. Для указания колонки можно использовать либо ее имя, либо ее номер. Например, если вторая колонка объекта ResultSet rs называется "title" и хранит строковое значение, то извлечь его можно одним из двух способов:
String s = rs.getString("title");
String s = rs.getString(2);
Как осуществляется запрос к базе данных и обработка результатов?
Выполнение запросов осуществляется путем вызова 1 из 3х методов объекта Statement:
executeQuery() (“выполнить запрос”): для выборки данных с помощью команды SELECT. Возвращает один объект ResultSet - набор значений, содержащий данные выборки.
executeUpdate() (“выполнить обновление”) - для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов DDL (Data Definition Language “язык описания данных”. Например, CREATE TABLE и DROP TABLE). Метод возвращает int - сколько записей было изменено;
execute() – исполняется, для выполнения запросов, которые могут возвращать различные результаты.
Возвращает true, если первый результат содержит ResultSet и false, если первый результат - это количество модифицированных записей или результат отсутствует.
Чтобы получить первый результат необходимо вызвать метод getResultSet() или getUpdateCount(). Остальные результаты доступны через вызов getMoreResults(), который при необходимости может быть произведен многократно.
Что такое ResultSet? Как с ним работать?
Объект хранит в себе результат запроса к базе данных - некий набор данных, внутри которого есть курсор, указывающий на один из элементов набора данных - текущую запись.
После запроса курсор-итератор устанавливается на позиции перед первой строкой. И чтобы переместиться к первой строке (и ко всем последующим) необходимо вызвать метод next().
Пока в наборе ResultSet есть доступные строки, метод next возвращает true. Поэтому часто используется конструкция: while (resultSet.next()) {}
А содержание полей записи получают с помощью спец. геттеров:
resultSet.getInt(“Номер или имя колонки”), .getString(“..”) и им подобных.
Рассказать про паттерн DAO
Суть паттерна DAO - отделить, абстрагировать взаимодействия с источником данных от
бизнес-логики.
Вся логика работы с конкретным хранилищем данных скрывается в DAO классах.
А код отвечающий за бизнес-логику, “сервисы”, взаимодействует с этими классами, а не с хранилищем непосредственно.
DAO дает возможность отделить логику (интерфейс) от реализации. Создавать любое количество реализаций и переключаться между ними не беспокоя пользователей.
Что такое ORM?
Object - Relational Mapping (“Объектно - реляционное отображение”) - концепция, подход к работе с БД, суть которой - работа с таблицами БД как с объектами. Т.е. мы описываем связь между
классами и таблицами БД, производит т.н. Mapping.
А затем работаем с java объектами, а не с таблицами БД.
Что такое JPA?
Java Persistence API это спецификация (документ), описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде.
Сама Java не содержит реализации JPA, но есть множества реализаций данной спецификации от разных компаний (открытых и нет).
В чем разница между JPA и Hibernate? Как связаны эти понятия?
JPA это спецификация, которая только описывает правила и API для реализации принципов ORM, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA).
Что такое Hibernate?
Hibernate самая популярная (практически стандарт) открытая реализация спецификации JPA.
А лучше сказать - “Соответствующая спецификации JPA”.
Это Java Framework обеспечивающий промежуточный уровень между базой данных и кодом Java. Позволяющей работать с сущностями Java не задумываясь как они хранятся в БД.
Основные возможности Hibernate:
1. Позволяет сократить объемы низкоуровневого шаблонного кода.
Большинство SQL запросов уже реализованы - нужно просто использовать готовые методы.
2. Автоматическая генерация и обновление таблиц в БД
3. Содержит “под капотом” полезные “фишки” по работе с БД - кеширование, настройка получения взаимосвязанных сущностей и др.
Какие классы / интерфейсы относятся к JPA / Hibernate?
Классы / Интерфейсы JPA
Persistence - основная цель объекта - получить объект EntityManagerFactory
с помощью статического метод createEntityManagerFactory.
EntityManagerFactory - фабричный класс (класс для создания объектов другого класса) для EntityManager. Он создает и управляет несколькими экземплярами EntityManager.
EntityManager - интерфейс, олицетворяющий соединение с базой данных и фабрика для Query.
EntityTransaction - интерфейс, создается из EntityManager для выполнения транзакций.
Query (“запрос”) - интерфейс, создается из EntityManager.
Используется для выполнения запроса к БД.
Классы / Интерфейсы Hibernate
Configuration - используется для конфигурирования Hibernate и создания SessionFactory.
SessionFactory - из него мы получаем объекты типа Session. Создается при старте приложения в количестве 1 штука для БД.
SessionFactory также кэширует информации для сокращения запросов к БД. Существуют несколько способов получить SessionFactory, один из которых: configuration.buildSessionFactory()
Session - основной интерфейс - мост между приложением и Hibernate, через который производятся все CRUD-операции с объектами-сущностями.
Живет только в пределах логической транзакции.
Создается из SessionFactory: sessionFactory.openSession()
Также, интерфейс Session:
- реализует кэш первого уровня
- управляет транзакциями
- является фабрикой для Transaction
 - короткоживущий объект, используемый для атомарных операций (операция, которая либо выполняется целиком, либо не выполняется вовсе). Это абстракция от JDBC.
Query (“запрос”) - объект использует HQL или SQL для выполнения запросов к БД:
session.createSQLQuery("DROP TABLE user").executeUpdate()
Основные аннотации Hibernate
@Entity - Объявляет класс сущностью.
@Table - Определяет таблицу базы данных для данной сущности (схему БД).
Если не указана = имя_класса. Пример: @Table (name = "users_table").
@Column - Определяет колонку БД, в которой будут храниться значения поля.
Если не указана = имя_поля_класса.	Пример: @Column (name = "user_name")
@Lob - указывает, что данный атрибут не имеет ограничений длины.
Применяется совместно с аннотацией @Column.
@Id - поля является идентификатором объектов этого класса, т.е. первичным ключом сущности.
@GeneratedValue - данное поле будет генерироваться автоматически в БД.
Пример: @GeneratedValue(strategy = GenerationType.IDENTITY)
@Transient - исключить поле из хранения в БД. static и final поля всегда transient.
@OneToOne, @ManyToOne, @OneToMany, @ManyToMany - аннотации для связи ассоциаций.
@Version - управление версией. При изменении записи в БД будет увеличиваться на 1.
@OrderBy - указание сортировки. При выборке записи будет отсортированы.
Пример: @OrderBy("firstName asc")
Рассказать про каждый GeneratedType (типы генерации @GeneratedValue)
@GeneratedValue главным образом заключается в создании уникально идентифицированного первичного ключа для объекта.
(JPA требует, чтобы каждый объект должен иметь один и только один первичный ключ)
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "name")
GenerationType.TABLE - для генерации уникального значения используется отдельная таблица, которая эмулирует последовательность. Когда требуется новое значение, JPA провайдер блокирует строку таблицы, обновляет хранящееся там значение и возвращает его обратно в приложение. Эта стратегия – наихудшая по производительности и ее желательно избегать.
GenerationType.SEQUENCE - используется последовательность,
специальный объект БД для генерации уникальных значений.
GenerationType.IDENTITY - используется встроенный в БД тип данных столбца -identity - для генерации значения первичного ключа. Он опирается на auto-increment колонку в таблице.
GenerationType.AUTO - означает, что JPA провайдер решает, как генерировать уникальные ID для нашей сущности. Выбор генератора осуществляется на основе диалекта.
Обязательны ли аннотации @Column и @Table?
Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.
Во всех остальных случаях, все поля в классе, помеченном как @Entity, неявно станут столбцами этой таблицы.
@Table - устанавливается на уровне класса и позволяет задать имя таблицы, каталог или схему
базы данных, а также установить уникальные ключи.
Если аннотация @Table не задана, то в качестве имени таблицы используется имя класса.
Что делать, если я не хочу сохранять какое-то поле в БД?
Используйте аннотацию @Transient.
Она будет означать, что поле не будет персистентным, т.е. не будет сохраняться в БД.
И соответственно не будет заполняться значением при получении объекта из БД.


Для чего нужны @Id и @GeneratedValue?
@id для указания что он ключ.
@GeneratedValue используется для указания способа создания первичного ключа.
Например , при использовании Mysql вы можете указать auto_increment в определении таблицы, чтобы сделать ее самоинкрементной, а затем использовать.
@GeneratedValue(strategy = GenerationType.IDENTITY).
Как достать все записи из таблицы используя HQL?
session.createQuery("FROM User").getResultList();
Чем HQL отличается от SQL?
HQL (Hibernate Query Language) - это объектно-ориентированный язык запросов, который очень похож на SQL. Главное различие языков HQL и SQL связано с тем, что SQL формирует запросы из наименований таблиц и столбцов в БД, а HQL работает с сущностями (классами) и их полями.
HQL поддерживает такие понятия, как полиморфизм, наследование, ассоциация.
Hibernate транслирует HQL–запросы в понятные для БД SQL–запросы, которые и выполняют необходимые действия в БД.
Что такое Query? Как передать в объект Query параметры?
Query (“запрос”) - объект, который использует HQL или SQL для выполнения запросов к БД.
В запросе можно использовать именованные параметры.
А с помощью метода setParameter вставлять конкретные значения параметров в запрос.
session.createQuery("delete User where id = :id").setParameter("id", id) .executeUpdate();
Какие можно устанавливать параметры в hbm2ddl, рассказать про них
hibernate.hbm2ddl.auto" - параметр настройки Hibernate, который определяет, что делать, с таблицами БД, если их нет или они отличаются о того что описано в классах-сущностях.
Действия совершаются при инициализации SessionFactory.
Возможные значения:
create - создать таблицы заново, уничтожив предыдущие данные.
create-drop - аналогично create, только после закрытия SessionFactory - удалить таблицы с данными.
validate - проверить БД, если соответствия нет ,то выбросить исключение.
update - проверить БД и при необходимости обновить таблицы и сохранить данные.
none - ничего не делать с БД.
Требования JPA к Entity-классам? Не менее пяти
- Entity класс должен быть помечен аннотацией Entity или описан в XML файле конфигурации JPA.
- Entity класс должен содержать public или protected конструктор без аргументов.
(он также может иметь конструкторы с аргументами).
- Entity класс должен быть классом верхнего уровня (top-level class).
- Entity класс не может быть enum или интерфейсом.
- Entity класс не может быть финальным классом (final class - от него нельзя наследоваться).
- Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables).
- Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс.
- Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе).
- Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных.
Жизненный цикл Entity в Hibernate
- New (Transient) - объект, который никогда не был связан с сессией Hibernate и не маппированный на какую-нибудь строку в таблице БД.
- Managed (Persistent) - сущность связана со строкой в таблице БД
(но физически может там пока отсутствовать).
- Detached - сущность связана с таблицей БД, но не управляется (или больше не управляется) Hibernate (persistence context был закрыт, либо экземпляр был удален из него).
- Removed - объект создан, управляется Hibernate, но запланирован к удалению из БД

Кэш в Hibernate
Кэш - механизм ускорения работы с БД посредством уменьшения количества запросов к ней за счет использования более высокоскоростного временного уровня хранения.
В Hibernate есть несколько кэшей:
1. Кэш первого уровня - Session (либо EntityManager - ее аналог в JPA).
Кеш первого уровня работает в пределах сессии. Hibernate всегда по умолчанию использует этот кеш и отключить его нельзя. Как он работает: отслеживаемые сущности хранятся в Map: ключ - id, значение - сущность. Если сущность извлекается из БД, то она помещается в этот Map и хранится до закрытия сессии. А при повторном извлечении она берется уже из Map и запроса select к БД не будет.
2. Кэш второго уровня – SessionFactory
Кеш второго уровня работает для всех сессий, созданных из данной фабрики сессий.
По умолчанию - выключен. Чтобы начать его использовать нужно:
- пометить классы, которые необходимо кэшировать, аннотацией @Cache
с выбранной стратегией кэширования для класса (usage = CacheConcurrencyStrategy.READ_WRITE).
Или указать настройку, которая по умолчанию то все классы будут по умолчанию кешироваться
- в файле конфигурации добавить параметр: use_second_level_cache: true и указать провайдер кэша.
Сам Hibernate не реализует кеширование второго уровня, а дает возможность подключить внешнюю совместимую реализацию.
Выбор провайдера зависит от стратегии, которые он может поддерживать:
Read-only, Read-write, Nonstrict-read-write (нестрогое чтение-запись: чтение и неконкурентное обновление), Transactional (изменения в кэше и изменения в БД, записываются в одной транзакции):
EHCache (Easy Hibernate Cache), OSCache (Open Symphony Cache), Swarm Cache, JBoss Tree Cache.
3. Кэш запросов (Query Cache)
Сохраняет запросы и их результаты. Дает повышение производительности при многократном повторении одинаковых запросов. Но несет накладные расходы по производительности, поэтому по умолчанию выключен. Чтобы его включить, нужно:
- указать в конфигурации: hibernate.cache.use_query_cache = “true”
- настроить таймаут региона кэширования
- разрешать кэширование запросов для конкретных запросов


Что такое Git
Git система контроля версий, которая даёт возможность разработчикам отслеживать изменения в файлах и работать совместно с другими разработчиками.
Был создан Линусом Торвальдсом для разработки ядра Linux в 2005 году.
Она не единственная, есть еще: SVN, Mercurial
Индекс в Git
Индекс в Git - это промежуточная область между рабочей директории и репозиторием.
При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс.
Индекс это возможность сформировать текущий коммит именно из тех файлов, которые нам нужны, оставил для другого коммита другие параллельные правки.
Возможные состояния файла в Git
- Не отслеживаемый.
- Отслеживаемый: измененный / не измененный.
- Индексированный (измененный, добавленный в индекс).
- Зафиксированный (сохраненный в локальном репозитории).
Как отменить последний коммит?
Командой git reset. У нее 3 варианта:
1. git reset HEAD~1 (аналогично: git reset --mixed HEAD~1). Режим по умолчанию.
Возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в не отслеживаемую (unstaged) зону.
2. git reset --soft HEAD~1
Возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в отслеживаемую (staged) зону.
3. git reset --hard HEAD~1
Возвращает проект к указанному коммиту, при этом полностью удаляет все коммиты после указанного.
Отличия между командами merge и rebase
Merge и Rebase преследуют одну и ту же цель интегрируют изменения из одной ветки в другую.
Но принципы работы разные:
merge (слияние) - создает коммит слияния. И после merge остаются три удобных коммита. Для продолжения работы можно использовать первую или вторую нить, или объединенную. Т.е. сохраняется история. Минусы - загрязняется история множеством коммитов.
rebase (перемещение) - работая в отдельной ветке, желая подтянуть изменения с основной, делаем rebase с master и наша ветка окажется после всех коммитов ветки master. Т.е. git переместит все коммиты вашей ветки на последний коммит ветки master. Т.е. это команда переписывает историю и не будет видно когда делали обновления с основной ветки.
ACID (свойства транзакции)
Транзакция это набор операций, которые могут быть либо целиком и успешно выполнены,
либо полностью не выполнены.
ACID описывает требования к транзакционной системе.
Atomicity — Атомарность
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.
Consistency — Согласованность
Это свойство даёт гарантию того, что все данные будут целостны. Данные будут корректны в соотвествии со всеми предопределёнными правилами, ограничениями, каскадами и триггерами, применёнными к БД.
Isolation — Изолированность
Гарантирует, что все транзакции будут выполняться изолированно. Ни одна транзакция не зааффектит на другую транзакцию. Другими словами, одна транзакция не сможет прочитать данные второй транзакции, которая ещё не выполнилась.
Durability — Надёжность
Durability означает, что когда транзакция будет применена, она останется в системе, даже если БД упала сразу после выполнения этой транзакции. Любые изменения, внесённые транзакцией, должны оставаться навсегда. Если БД сообщила об успешном выполнении транзакции, то она должна быть действительно применена.
